<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="cfslcfaqs" kind="page">
    <compoundname>cfslcfaqs</compoundname>
    <title>CFS Limit Checker Frequently Asked Questions</title>
    <detaileddescription>
<para><heading level="1">Watchpoint Questions </heading>
</para><para><bold> (Q) Watchpoints evaluate to <ref refid="lc__tbldefs_8h_1a460943a8ab1a97e5b296e3b974877abf" kindref="member">LC_WATCH_TRUE</ref> or <ref refid="lc__tbldefs_8h_1ad3dfc9c5fed52150fb7d7f252cbb5fe3" kindref="member">LC_WATCH_FALSE</ref>. When the the watchpoint is defined which should be the error condition? </bold> <linebreak/>
 <linebreak/>
 <emphasis> Watchpoints evaluate to a boolean True or False. So if you setup a comparison &lt; 100 any watchpoint value 0 to 99 will evaluate <ref refid="lc__tbldefs_8h_1a460943a8ab1a97e5b296e3b974877abf" kindref="member">LC_WATCH_TRUE</ref> and 100+ will be <ref refid="lc__tbldefs_8h_1ad3dfc9c5fed52150fb7d7f252cbb5fe3" kindref="member">LC_WATCH_FALSE</ref>.</emphasis></para><para><emphasis> You want to construct the watchpoint cases so they evaluate True when you are outside of the acceptable range for a telemetry point. That&apos;s why there are cumulative and consecutive true counts in the watchpoint results table, but no corresponding values for False.</emphasis></para><para><emphasis> For some examples, see the file lc_def_wdt.c </emphasis></para><para><bold> (Q) There is only a single comparison value for each watchpoint. How can I have multiple thresholds for a single telemetry point? </bold> <linebreak/>
 <linebreak/>
 <emphasis> Create additional watchpoint definitions that reference the same telemetry point but have different comparison values. The watchpoints will be evaluated in the order they are listed in the WDT when the monitor point arrives.</emphasis></para><para><emphasis> Having multiple watchpoints allows different Actionpoints to trigger on each watchpoint state (or combination of states). </emphasis></para><para><bold> (Q) How do I calculate the watchpoint offset? </bold> <linebreak/>
 <linebreak/>
 <emphasis> The offset is a zero based byte offset from the beginning of the message (including any headers) to the first byte of the watchpoint data. So for a cFE raw command using CCSDS, the offset has to account for the size of the cFE command header (<ref refid="cfe__sb_8h_1acc49ae58990b23f72824e1b742c78cb8" kindref="member" external="/home/vagrant/airliner/build/reference/default/docs/html/cfe/detailed_design/cfe.tag">CFE_SB_CMD_HDR_SIZE</ref>). </emphasis></para><para><bold> (Q) When do I need to use the bitmask in a watchpoint definition? </bold> <linebreak/>
 <linebreak/>
 <emphasis> All watchpoints are sized to a 32 bit value when extracted from a message. The specified bitmask value is then applied (as a bitwise AND operation) before the comparison is made or the custom function is called.</emphasis></para><para><emphasis> When the watchpoint data is sized, data types smaller than 32 bits are properly sign or zero extended. For this reason, it is not necessary to define a mask for UWORD, WORD or UBYTE, BYTE data types to compare properly. Although it&apos;s not needed, a properly constructed bit mask will not cause a problem for these evaluations either.</emphasis></para><para><emphasis> When you really need to use a bitmask is when monitoring odd sized data (such as a 24 bit sensor reading) or testing data to see if certain bits have been set (or cleared).</emphasis></para><para><emphasis> When no bitmask is needed, be sure to use the constant <ref refid="lc__tbldefs_8h_1a7e009458f514dfdc0b7f98ed3fdc927b" kindref="member">LC_NO_BITMASK</ref> (or it&apos;s equivalent value 0xFFFFFFFF) in your WDT tables. Since masking is a bitwise AND, setting the bitmask to zero will have the effect of always clearing the watchpoint data prior to comparison. </emphasis></para><para><bold> (Q) Why do I need to specify the byte order (big or little endian) of the watchpoint data type? </bold> <linebreak/>
 <linebreak/>
 <emphasis> One enhancement made to the CFS version of LC is that it will properly byte swap watchpoint data prior to masking and comparison if the byte order of the data is different than the order used by the processor running LC. This allows LC to monitor telemetry data that might be constructed by instrument or other subsystem processors that use a different byte order.</emphasis></para><para><emphasis> LC determines it&apos;s byte order using the <emphasis>STRUCT_HIGH_BIT_FIRST</emphasis> and <emphasis>STRUCT_LOW_BIT_FIRST</emphasis> compiler switches that are set in the cFE header <ref refid="common__types_8h" kindref="compound" external="/home/vagrant/airliner/build/reference/default/docs/html/cfe/detailed_design/cfe.tag">common_types.h</ref> according to the platform designated in the cFE platform makefile. </emphasis></para><para><bold> (Q) When would a watchpoint evalute to #LC_WATCH_NOT_MEASURED? </bold> <linebreak/>
 <linebreak/>
 <emphasis> #LC_WATCH_NOT_MEASURED is an initialization value for the Watchpoint Results Table. If a watchpoint has this WatchResult then the watchpoint is unused (the DataType in the WDT is set to <ref refid="lc__tbldefs_8h_1ab375eb9a6810f8ed483616227b37846c" kindref="member">LC_WATCH_NOT_USED</ref>) or a message that contains the watchpoint has not yet been recieved by LC and evaluated. </emphasis></para><para><bold> (Q) When would a watchpoint evalute to <ref refid="lc__tbldefs_8h_1ac92b16019803fd9448eab79d1266973c" kindref="member">LC_WATCH_ERROR</ref>? </bold> <linebreak/>
 <linebreak/>
 <emphasis> <ref refid="lc__tbldefs_8h_1ac92b16019803fd9448eab79d1266973c" kindref="member">LC_WATCH_ERROR</ref> is a runtime error indicator for watchpoint processing. Such a result should be rare since most of the causes are invalid watchpoint parameters that should be caught during validation of the Watchpoint Definition Table.</emphasis></para><para><emphasis> One notable exception is for floating point watchpoints when the message data is detected to be a floating point NAN (Not-A-Number) that can&apos;t be relationally compared to any value.</emphasis></para><para><emphasis> In all cases, an error event detailing the cause of the problem will be issued when a WatchResult is set to <ref refid="lc__tbldefs_8h_1ac92b16019803fd9448eab79d1266973c" kindref="member">LC_WATCH_ERROR</ref>. </emphasis></para><para><bold> (Q) What is a custom function and how do I create one? </bold> <linebreak/>
 <linebreak/>
 <emphasis> A custom function is a way to do more complicated processing on a watchpoint when the standard comparison operators are not adequate.</emphasis></para><para><emphasis> When the OperatorID in a watchpoint definition is set to <ref refid="lc__tbldefs_8h_1a641b55ad4210e3a2700b0bc929809cb9" kindref="member">LC_OPER_CUSTOM</ref>. The function /LC_CustomFunction is called instead of LC doing a comparison. /LC_CustomFunction will then return <ref refid="lc__tbldefs_8h_1a460943a8ab1a97e5b296e3b974877abf" kindref="member">LC_WATCH_TRUE</ref> or <ref refid="lc__tbldefs_8h_1ad3dfc9c5fed52150fb7d7f252cbb5fe3" kindref="member">LC_WATCH_FALSE</ref> that will be used as the WatchResult.</emphasis></para><para><emphasis> Although /LC_CustomFunction is the same entry point for all watchpoints with a designated custom function operator, a mission can modify the function body to switch on the watchpoint ID (or CustomFuncArgument specified in the watchpoint definition) and branch to as many different sub-functions as it needs for watchpoint specific processing.</emphasis></para><para><emphasis> The /LC_CustomFunction stub is in the source file lc_custom.c </emphasis></para><para><bold> (Q) How is the WPResults array in the housekeeping packet (<ref refid="struct_l_c___hk_packet__t" kindref="compound">LC_HkPacket_t</ref>) interpreted? </bold> <linebreak/>
 <linebreak/>
 <emphasis> The WPResults array is a byte array (aligned to the nearest longword boundary) that contains a packed subset of the current contents of the Watchpoint Results Table (see <ref refid="struct_l_c___w_r_t_entry__t" kindref="compound">LC_WRTEntry_t</ref>).</emphasis></para><para><emphasis> It allocates 2 bits per watchpoint for the most recent watchpoint comparison result. The numerical 2 bit values are defined using the following constants:</emphasis></para><para><emphasis> <ref refid="lc__msgdefs_8h_1a758c7adddbe89ab84001bfc52a1640d2" kindref="member">LC_HKWR_FALSE</ref>, <ref refid="lc__msgdefs_8h_1ae654588064c07a1a2188c6e739b9286e" kindref="member">LC_HKWR_TRUE</ref>, <ref refid="lc__msgdefs_8h_1a8c3a6be636c94eebcdf4c88e2bce5e7e" kindref="member">LC_HKWR_ERROR</ref>, #LC_HKWR_NOT_MEASURED</emphasis></para><para><emphasis> Ordering (up to <ref refid="lc__platform__cfg_8h_1a3b43c5fab123709355610bb6382804d3" kindref="member">LC_MAX_WATCHPOINTS</ref>) is as follows :</emphasis></para><para><emphasis> Byte 0:(Rwp3, Rwp2, Rwp1, Rwp0), Byte 1:(Rwp7, Rwp6, Rwp5, Rwp4), etc...</emphasis></para><para><emphasis> The WPResults array is constructed every housekeeping cycle and is not effected by the reset counters (<ref refid="lc__msgdefs_8h_1ad5da547462d67a5e93e2a1af34fddd01" kindref="member">LC_RESET_CC</ref>) ground command. It will only get cleared if the Watchpoint Results Table is reset (via a new WDT table load or with a <ref refid="lc__msgdefs_8h_1a8c47e49846b71cf6addd1750396953f8" kindref="member">LC_RESET_WP_STATS_CC</ref> ground command) </emphasis></para><para><heading level="1">Actionpoint Questions </heading>
</para><para><bold> (Q) Actionpoints evaluate to <ref refid="lc__tbldefs_8h_1a0d820b4ac78559654a530fca07d3618d" kindref="member">LC_ACTION_PASS</ref> or <ref refid="lc__tbldefs_8h_1a9b113f330c8222236cf4e92732e024c5" kindref="member">LC_ACTION_FAIL</ref>. How should the RPN expression get constructed so it will evaluate to the proper result? </bold> <linebreak/>
 <linebreak/>
 <emphasis> Actionpoint RPN expressions are combinations of watchpoint states and logical operators that evaluate to a boolean True or False.</emphasis></para><para><emphasis> Just like a watchpoint evaluation of True indicates a parameter outside acceptable limits, an AP expression that evaluates True is considered to have Failed and will have it&apos;s ActionResult set to <ref refid="lc__tbldefs_8h_1a9b113f330c8222236cf4e92732e024c5" kindref="member">LC_ACTION_FAIL</ref>.</emphasis></para><para><emphasis> While the terminology may seem confusing, the key point is to construct both watchpoint and actionpoint expressions to define the error condition LC is looking for and NOT the normal condition of the spacecraft data stream.</emphasis></para><para><emphasis> For some examples, see the file lc_def_adt.c </emphasis></para><para><bold> (Q) When would a actionpoint evalute to #LC_ACTION_NOT_MEASURED? </bold> <linebreak/>
 <linebreak/>
 <emphasis> #LC_ACTION_NOT_MEASURED is an initialization value for the Actionpoint Results Table. If an actionpoint has this ActionResult then one of three possible conditions are true:</emphasis></para><para><emphasis> 1) The actionpoint is unused (the DefaultState in the ADT is set to <ref refid="lc__msgdefs_8h_1ac156605f5aaa3c12b9c2ad2af5b28569" kindref="member">LC_ACTION_NOT_USED</ref>).</emphasis></para><para><emphasis> 2) An actionpoint sample request (<ref refid="lc__msgids_8h_1a156d2d4b7fa00933aa4f34253f8dfe74" kindref="member">LC_SAMPLE_AP_MID</ref>) targeting the AP has not yet been recieved by LC so the AP has not yet been evaluated.</emphasis></para><para><emphasis> 3) One or more of the watchpoints that this AP depends on (as defined by the RPN expression) has a current WatchResult of #LC_WATCH_NOT_MEASURED so the AP can&apos;t be evaluated. </emphasis></para><para><bold> (Q) When would a actionpoint evalute to <ref refid="lc__tbldefs_8h_1a69b1f15ea8bd9f62b4f3ea9eab7dcfa6" kindref="member">LC_ACTION_ERROR</ref>? </bold> <linebreak/>
 <linebreak/>
 <emphasis> <ref refid="lc__tbldefs_8h_1a69b1f15ea8bd9f62b4f3ea9eab7dcfa6" kindref="member">LC_ACTION_ERROR</ref> is a runtime error indicator for actionpoint processing. Such a result should be rare since most of the causes are invalid actionpoint parameters or improperly constructed RPN expressions that should be caught during validation of the Actionpoint Definition Table.</emphasis></para><para><emphasis> However, an exception is the case where one or more watchpoints that this AP depends on (as defined by the RPN expression) has a current WatchResult of <ref refid="lc__tbldefs_8h_1ac92b16019803fd9448eab79d1266973c" kindref="member">LC_WATCH_ERROR</ref>. Since the AP can&apos;t be evaluated, this will cause the ActionResult to be set to <ref refid="lc__tbldefs_8h_1a69b1f15ea8bd9f62b4f3ea9eab7dcfa6" kindref="member">LC_ACTION_ERROR</ref>.</emphasis></para><para><emphasis> In all cases, an error event detailing the cause of the problem will be issued when an ActionResult is set to <ref refid="lc__tbldefs_8h_1a69b1f15ea8bd9f62b4f3ea9eab7dcfa6" kindref="member">LC_ACTION_ERROR</ref>. </emphasis></para><para><bold> (Q) How does the Actionpoint state <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref> differ from <ref refid="lc__msgdefs_8h_1abebab7aac8a748c086cdf4b74dcdd489" kindref="member">LC_APSTATE_DISABLED</ref>? </bold> <linebreak/>
 <linebreak/>
 <emphasis> The AP state <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref> is intended to provide a way to disable an AP so it can not easily be turned back on by mistake. Such actionpoints may not be needed after a seperation sequence or only apply to certain mission phases.</emphasis></para><para><emphasis> While the two states are treated the same way during actionpoint processing (the AP isn&apos;t evaluated), there are a few differences.</emphasis></para><para><emphasis> An AP can&apos;t be set to <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref> with the <ref refid="lc__msgdefs_8h_1a65ef61d17b6006a1f24bbeb61de06612" kindref="member">LC_SET_AP_STATE_CC</ref> command, it must be done with the <ref refid="lc__msgdefs_8h_1a6a28b576275502e48c64148592cdf132" kindref="member">LC_SET_AP_PERMOFF_CC</ref> command.</emphasis></para><para><emphasis> To set an AP to <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref> with the <ref refid="lc__msgdefs_8h_1a6a28b576275502e48c64148592cdf132" kindref="member">LC_SET_AP_PERMOFF_CC</ref> command, the current AP state must be <ref refid="lc__msgdefs_8h_1abebab7aac8a748c086cdf4b74dcdd489" kindref="member">LC_APSTATE_DISABLED</ref>.</emphasis></para><para><emphasis> The <ref refid="lc__msgdefs_8h_1a6a28b576275502e48c64148592cdf132" kindref="member">LC_SET_AP_PERMOFF_CC</ref> command can only be issued for a single actionpoint, <ref refid="lc__msgids_8h_1a50337ddbcfd1a95eee220d44654a1326" kindref="member">LC_ALL_ACTIONPOINTS</ref> is not valid as an argument for this command.</emphasis></para><para><emphasis> Once an AP is set to <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref>, it can only be changed with a new ADT table load. </emphasis></para><para><bold> (Q) How is the APResults array in the housekeeping packet (<ref refid="struct_l_c___hk_packet__t" kindref="compound">LC_HkPacket_t</ref>) interpreted? </bold> <linebreak/>
 <linebreak/>
 <emphasis> The APResults array is a byte array (aligned to the nearest longword boundary) that contains a packed subset of the current contents of the Actionpoint Results Table (see <ref refid="struct_l_c___a_r_t_entry__t" kindref="compound">LC_ARTEntry_t</ref>).</emphasis></para><para><emphasis> It allocates 4 bits per actionpoint, with 2 bits representing the current state, and 2 bits for the most recent evaluation result.</emphasis></para><para><emphasis> The numerical 2 bit values for current state are defined using the following constants:</emphasis></para><para><emphasis> <ref refid="lc__msgdefs_8h_1a29c0dbf956f340df504f9c764b0bf3f0" kindref="member">LC_HKAR_STATE_NOT_USED</ref>, <ref refid="lc__msgdefs_8h_1ae34fd035326e2a89f9ca18072ea659f4" kindref="member">LC_HKAR_STATE_ACTIVE</ref>, <ref refid="lc__msgdefs_8h_1a619262153bc9eec8ccd5879d597d2ce7" kindref="member">LC_HKAR_STATE_PASSIVE</ref>, <ref refid="lc__msgdefs_8h_1a8e9d87376322eed0253677aeffd93adc" kindref="member">LC_HKAR_STATE_DISABLED</ref></emphasis></para><para><emphasis> An actionpoint whose current state is <ref refid="lc__msgdefs_8h_1a96216b9bd442bbfb94406364260ea711" kindref="member">LC_APSTATE_PERMOFF</ref> will have it&apos;s state reported in the APResults as <ref refid="lc__msgdefs_8h_1a29c0dbf956f340df504f9c764b0bf3f0" kindref="member">LC_HKAR_STATE_NOT_USED</ref>.</emphasis></para><para><emphasis> The numerical 2 bit values for evaluation results are defined using the following constants:</emphasis></para><para><emphasis> <ref refid="lc__msgdefs_8h_1a71f35182ae926b8a667ad6c033c83bae" kindref="member">LC_HKAR_PASS</ref>, <ref refid="lc__msgdefs_8h_1a2f8f7c3ee75a5ca46b8b709e33d45f24" kindref="member">LC_HKAR_FAIL</ref>, <ref refid="lc__msgdefs_8h_1a0f5097aa9369197af2650a1d07320c95" kindref="member">LC_HKAR_ERROR</ref>, #LC_HKAR_NOT_MEASURED</emphasis></para><para><emphasis> Ordering (up to <ref refid="lc__platform__cfg_8h_1ab49788ed10c3f7f4aaaa876a48b49ba3" kindref="member">LC_MAX_ACTIONPOINTS</ref>) is as follows :</emphasis></para><para><emphasis> Byte 0:(Sap1, Rap1, Sap0, Rap0), Byte 1:(Sap3, Rap3, Sap2, Rap2), etc...</emphasis></para><para><emphasis> The APResults array is constructed every housekeeping cycle and is not effected by the reset counters (<ref refid="lc__msgdefs_8h_1ad5da547462d67a5e93e2a1af34fddd01" kindref="member">LC_RESET_CC</ref>) ground command. It will only get cleared if the Actionpoint Results Table is reset (via a new ADT table load or with a <ref refid="lc__msgdefs_8h_1a3c3a4a2329644e392441e0e271eb0f90" kindref="member">LC_RESET_AP_STATS_CC</ref> ground command) </emphasis></para><para><bold> (Q) Will an RTS get requested more than once if an AP stays in the <ref refid="lc__tbldefs_8h_1a9b113f330c8222236cf4e92732e024c5" kindref="member">LC_ACTION_FAIL</ref> state? </bold> <linebreak/>
 <linebreak/>
 <emphasis> No. Assuming the current state of an actionpoint is <ref refid="lc__msgdefs_8h_1a8d7d19346c3a24515ee300e89c0fbcf6" kindref="member">LC_APSTATE_ACTIVE</ref>, then when the actionpoint fails enough times to trigger an RTS, the state is set to <ref refid="lc__msgdefs_8h_1a50c3fd705ae749e6b015d926e4183c54" kindref="member">LC_APSTATE_PASSIVE</ref>.</emphasis></para><para><emphasis> In the passive state, the AP will continue to be sampled and statistics updated, but no RTS requests will be initiated. </emphasis></para><para><bold> (Q) Can we filter event messages per actionpoint? </bold> <linebreak/>
 <linebreak/>
 <emphasis> Not in the current implementation. Transition event messages for actionpoints are of type <ref refid="cfe__evs_8h_1a5551720d052dd752fcf22af0dcdc9d4e" kindref="member" external="/home/vagrant/airliner/build/reference/default/docs/html/cfe/detailed_design/cfe.tag">CFE_EVS_DEBUG</ref> and enabling them will turn on events for all actionpoint transitions.</emphasis></para><para><emphasis> However, it is planned to add event message limits and event message counts to the ADT and ART tables that would allow this type of filtering in a future version of LC. </emphasis></para><para><bold> (Q) Can I send a single actionpoint evaluation message for multiple actionpoints (eg. 1,2,5,6,7)? </bold> <linebreak/>
 <linebreak/>
 <emphasis> No. You can send individual messages for each action point or a single message to evaluate ALL (xFFFF) actionpoints. </emphasis></para><para><bold> (Q) What if most of my actionpoints need to be evaluated at 1HZ but one needs to be evaluated at 10HZ. How would I setup the Scheduler table to do this? </bold> <linebreak/>
 <linebreak/>
 <emphasis> In order to evaluate an actionpoint, an evaluation message must be placed in the scheduler table. Since the scheduler table is evaluated at 1HZ, the suggested way to accomplish this is to place 9 entries for the 10HZ actionpoint and a single entry to evaluate ALL actionpoints. Note that the ALL actionpoints message needs to be placed 100ms away from the other 9. </emphasis></para><para><heading level="1">General Questions </heading>
</para><para><bold> (Q) When do results tables get cleared? </bold> <linebreak/>
 <linebreak/>
 <emphasis> When either the WDT or ADT are updated, the corresponding results table (WRT or ART) is reset to initialization values. For each entry in the WRT, WatchResult is set to #LC_WATCH_NOT_MEASURED and all other values are zeroed. For each entry in the ART, ActionResult is set to #LC_ACTION_NOT_MEASURED, the CurrentState is set to the value of the actionpoint&apos;s DefaultState specified in the ADT, and all other values are zeroed.</emphasis></para><para><emphasis> These are also the values used (for the entries specified in the command) when the <ref refid="lc__msgdefs_8h_1a3c3a4a2329644e392441e0e271eb0f90" kindref="member">LC_RESET_AP_STATS_CC</ref> or <ref refid="lc__msgdefs_8h_1a8c47e49846b71cf6addd1750396953f8" kindref="member">LC_RESET_WP_STATS_CC</ref> ground command is received. </emphasis></para><para><bold> (Q) Where can I find some examples of watchpoint and actionpoint table definitions? </bold> <linebreak/>
 <linebreak/>
 <emphasis> The files lc_def_wdt.c and lc_def_adt.c provide example source code files that can be used to build LC tables and contain some sample table entries in the comment blocks.</emphasis></para><para><emphasis> Since the CFS LC was based upon the LC implementation for LRO, LRO limit checker tables may also provide guidance though there are some minor differences in syntax between the two implementations. </emphasis></para><para><bold> (Q) When using the CDS, what is restored and when will defaults be used? </bold> <linebreak/>
 <linebreak/>
 <emphasis> When the platform configuration parameter LC_SAVE_TO_CDS is defined, LC will attempt to use the critical data store (CDS) to save and restore data across application restarts. The data that LC will save are:</emphasis></para><para><emphasis> Watchpoint and Actionpoint Definition Tables Watchpoint and Actionpoint Results Tables LC Housekeeping Data</emphasis></para><para><emphasis> While the definition tables only need to be updated in the CDS when new ones are loaded, it is not practical from a performance standpoint to update the CDS every time the housekeeping data or results data changes. For this reason, results tables and housekeeping are only updated in the CDS if the application is shut down by cFE Executive Services and exits cleanly. When the application starts, it will check a &quot;saved on exit&quot; flag in the data restored from CDS to see if the data is good. If not, it will be reset to initialization values.</emphasis></para><para><emphasis> The detailed sequence for a CDS restore on application startup (with failure cases) is as follows:</emphasis></para><para><emphasis> 1) Try to restore Watchpoint Definition Table from CDS If FAILS Load default Watchpoint Definition Table from filesystem Load default Actionpoint Definition Table from filesystem Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values</emphasis></para><para><emphasis> 2) If 1 succeeded, try to restore Actionpoint Definition Table from CDS If FAILS Load default Watchpoint Definition Table from filesystem Load default Actionpoint Definition Table from filesystem Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values</emphasis></para><para><emphasis> 3) If 1 and 2 succeeded, try to restore Watchpoint Results Table from CDS If FAILS Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values</emphasis></para><para><emphasis> 4) If 1 - 3 succeeded, try to restore Actionpoint Results Table from CDS If FAILS Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values</emphasis></para><para><emphasis> 5) If 1 - 4 succeeded, try to restore Application data (housekeeping variables) from CDS If FAILS Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values</emphasis></para><para><emphasis> 6) If 1 - 5 succeeded, check &quot;save on exit&quot; flag in application data restored in 5 IF not set to &quot;SAVED&quot; (meaning we updated on exit) Clear Watchpoint Results Table to init values Clear Actionpoint Results Table to init values Clear Housekeeping variables to init values </emphasis></para><para>Prev: <ref refid="cfslccons" kindref="compound">CFS Limit Checker Operational Constraints</ref> </para>    </detaileddescription>
  </compounddef>
</doxygen>

<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="cfssccons" kind="page">
    <compoundname>cfssccons</compoundname>
    <title>CFS Stored Command Constraints</title>
    <detaileddescription>
<para><heading level="2">Adjusting Time</heading>
</para><para>Because the SC application depends on the spacecraft clock to schedule itself and all of the active sequences, adjustments to spacecraft clock time (depending on what time format is configured) will have an effect on those active sequences. Adjusting the spacecraft clock time has different effects on active ATSs and RTSs.</para><para>The effect that adjusting time has on an ATS is predictable. Because each command has an absolute time tag associated with it, any sequence that is running will have a new frame of reference when the time is adjusted. For example, an ATS is started at 12:00 and it is waiting to send out commands starting at 2:00pm. If SC is configured to use UTC time, and the ATS is started and UTC time is adjusted to 1:00pm (by adjusting spacecraft time or the UTCF or both), the first ATS command will execute in an hour instead of two hours. If SC is conifured to use TAI time, and the ATS is started, and the leap seconds are changed, SC time will not be affected.</para><para>The effect of adjusting time on Relative Time Sequences is a little more complicated. As mentioned in the Scheduling section, the next RTS command for each sequence actually has an absolute time associated with it. With this absolute time, it is possible for SC to know when to send out each RTS command. From the Absolute time a delay time is computed, which is used to tell SC how long to delay. When time is adjusted on an RTS, the command that is currently waiting to execute gets &quot;thrown off&quot;. Depending on the time adjustment, the command could go out sooner or later than expected. Once the &quot;current&quot; command is out, however, the remaining commands in the sequence will execute as scheduled because they are relative to the previous command.</para><para>The point of this discussion is that SC will not react well to time changes. It is recommended that SC be idle during large time adjustments (1 second or greater). Small adjustments can be tolerated if there is not an exact second tolerance for every command being executed.</para><para><heading level="2">Over-scheduling the Stored Command Application</heading>
</para><para>Another way to stress SC is to send out many commands in one second from many sequences. The time tags for both ATS commands and RTS commands have one second resolution. However, there is a way to send multiple commands in one second. For ATS commands, set the time tags to the same second. For RTS commands, set the delays to zero. As noted earlier, SC will send out the commands as fast as possible up to a certain number of commands per second. With this in mind, it is possible to pack the ATSs and a few RTSs with commands that want to go out in the same second. When all of these sequences are run, SC will get behind in sending out the commands. SC will keep going until all of the commands are executed, but do not expect &quot;to the second&quot; execution accuracy.</para><para><heading level="2">Unsorted ATS Loads</heading>
</para><para>Although there is no requirement for the ATS command loads to be sorted in time order, having a full command load (Platform Defined ATS commands) of completely unsorted commands can cause the SC to block the execution of lower priority tasks until it is finished sorting. The recommendation is that maximum unsorted loads are not used.</para><para><heading level="2">ATS Switching Buffers</heading>
</para><para>Because the ATS switch is one of the most complicated SC operations, it is important to discuss the complete details of the ATS switch here. In normal operations, one ATS buffer will be running on the ATP, executing commands while the unused command buffer can be loaded and patched with the next sequence of commands. Because of the way the ATP skips commands that have time tags &quot;in the past&quot; when the ATS is started, the two ATS buffers can be built with some overlap in them. This allows a window of time during which the switch command could be sent. Figure 4.6 shows the overlapping buffer concept with the ATSs. As mentioned earlier, the ATP can execute commands with the same time tag. Because the resolution of the time tag only goes down to one second, in order to execute more than one command in one second, the commands should have the same time tag. Now suppose that the ATP receives the command to Switch ATSs while one ATS is in the middle of sending 8 commands out with the same time tag, and only 5 of these commands were sent out before the buffer is switched (assuming a switch command coming from the ground, not the internal switch command). At first glance this seems to work because the other ATS buffer has an overlap with the same 8 commands that want to go out in one second. This is where a problem occurs: when the new ATS is started, the ATP will walk down the list of commands until it finds a command with a time tag that is greater than or equal to the current time tag. Because the resolution of the time tags only goes down to a second, the ATP will execute all 8 commands in that one second, causing 5 of the eight commands to be sent out twice. In order to solve the problem of the ATS Switch sending out duplicate commands, the Switch ATS command received from the ground causes a wait condition until it is &quot;safe&quot; to switch the ATS buffer. So, when the Switch ATS command is received by the ATP, the command is validated and then a SWITCH_PEND flag is set. When it becomes safe for the ATS to switch (i.e. at a 1 second boundary in UTC Time), the switch will be serviced. This method assures that sending the Switch ATS command from the ground will not cause any duplicate commands to be sent out to the data system, nor any missed commands. Note that all of this switch logic only comes into use when there are multiple commands per second. The safe switch will wait until all commands during the current second have been sent out, then it will switch. If there are no commands with the same time tag in the overlap region (including the switch command) this logic does not get used. In either case, the switch can be performed without sending any duplicate commands to be sent out. There are certain conditions that can cause a ATS switch that is pending to be canceled. If the ATP is stopped by the ground while the ATP is waiting for a &quot;safe&quot; time to switch, then the switch will not occur. Also if the ATP detects the end of the ATS buffer before there is a &quot;safe&quot; time to switch, the switch will be canceled. Note that the typical time frame for a &quot;switch pend&quot; is one second or less. The operation of the switch is transparent to the ground.</para><para><heading level="2">Updating ATS/RTS Loads</heading>
</para><para>When creating and loading a new ATS or RTS table, it is recommended that the table to be updated is not executing. While updating an executing ATS or RTS is allowed, unexpected results may arise since the contents of the updated ATS or RTS will be executed after the table is activated.</para><para><heading level="2">Null ATS/RTS Loads</heading>
</para><para>Loading a NULL RTS or ATS is an invalid SC operation. In the event that the user does execute a NULL RTS the following happens: <orderedlist>
<listitem>
<para>An SC event message will be sent out. </para></listitem>
<listitem>
<para>The RTS that was being overwritten will NOT be cleared. </para></listitem>
</orderedlist>
</para><para>In the event that the user executes a NULL ATS the following happens: <orderedlist>
<listitem>
<para>An SC event message will be sent out. </para></listitem>
<listitem>
<para>The ATS and associated index and status tables will be cleared. </para></listitem>
</orderedlist>
</para><para><heading level="2">Table and File Naming Convention</heading>
</para><para>SC uses two types of loadable tables: ATS and RTS tables. Both the table file names and the table names contained in the file header need to follow a specific naming convention.</para><para><heading level="3">RTS&apos;s</heading>
</para><para>Because RTS&apos;s can be loaded at startup, the files for the those RTS&apos;s must be in a predetermined location as determined by the platform configuration parameter <ref refid="sc__platform__cfg_8h_1ac9337b61aaca7a2b7e153ae65b91caf1" kindref="member">SC_RTS_FILE_NAME</ref>. This location must be in non-volatile memory. Otherwise, the files would not exist upon a Power-On reset. Also, the RTS table file must be named according to a specific convention. The file name must start with whatever the <ref refid="sc__platform__cfg_8h_1a23348eaa39160aee4ca05bc41572b024" kindref="member">SC_RTS_TABLE_NAME</ref> platform configuration parameter is set to. Next must be a three digit number indicating which RTS this table file is, and the last must be &quot;.tbl&quot;. An example of this for RTS #1, with <ref refid="sc__platform__cfg_8h_1a23348eaa39160aee4ca05bc41572b024" kindref="member">SC_RTS_TABLE_NAME</ref> set to &quot;RTS_TBL&quot; would be: &apos;RTS_TBL001.tbl&apos;. In addition to the file naming convention, the name of the table contained within the table file should be the same as the file name, without the path or extension. Remember to also have the application name prefixed to the name of the table. For the file &apos;RTS_TBL001.tbl&apos;, its table name should be &apos;SC.RTS_TBL001, if the name of the application is &quot;SC&quot;.</para><para><heading level="3">ATS&apos;s</heading>
</para><para>ATS&apos;s are not loaded at startup, nor are they loaded automatically at any other time. Therefore, neither the name of the file of the ATS nor the file&apos;s location matter. All that matters to SC is the name of the table itself in the header of the table file. The name should either be &apos;SC.ATS_TBL1&apos; or &apos;SC.ATS_TBL2&apos; provided that the name of the the application is &quot;SC&quot; and which ATS the table is meant for (1 is for A, 2 is for B).</para><para>Next: <ref refid="cfsscfaqs" kindref="compound">CFS Stored Command Frequently Asked Questions</ref> <linebreak/>
 Prev: <ref refid="cfssccfg" kindref="compound">CFS Stored Command Configuration Parameters</ref> </para>    </detaileddescription>
  </compounddef>
</doxygen>
